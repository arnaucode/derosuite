// Copyright 2017-2018 DERO Project. All rights reserved.
// Use of this source code in any form is governed by RESEARCH license.
// license can be found in the LICENSE file.
// GPG: 0F39 E425 8C65 3947 702A  8234 08B2 0360 A03A 9DE8
//
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

package checkpoints

// generate main net checkpoints automatically from file mainnet_checkpoints.dat

//go:generate sh -c "echo // Code generated by go generate DO NOT EDIT. > mainnet_checkpoints.go"
//go:generate sh -c "echo // This file contains all the mainnet checkpoints > mainnet_checkpoints.go"
//go:generate sh -c "echo // please read checkpoints.go comments > mainnet_checkpoints.go"
//go:generate sh -c "echo package checkpoints >> mainnet_checkpoints.go"
//go:generate sh -c "echo  >> mainnet_checkpoints.go"
//go:generate sh -c "echo var mainnet_checkpoints = []byte{ >> mainnet_checkpoints.go"
//go:generate sh -c "xxd -i <  mainnet_checkpoints.dat >> mainnet_checkpoints.go"
//go:generate sh -c "truncate -s-1 mainnet_checkpoints.go"
//go:generate sh -c "echo ,} >> mainnet_checkpoints.go"

//go:generate sh -c "echo // Code generated by go generate DO NOT EDIT. > testnet_checkpoints.go"
//go:generate sh -c "echo // This file contains all the testnet checkpoints > testnet_checkpoints.go"
//go:generate sh -c "echo // please read checkpoints.go comments > testnet_checkpoints.go"
//go:generate sh -c "echo package checkpoints >> testnet_checkpoints.go"
//go:generate sh -c "echo  >> testnet_checkpoints.go"

// generate blank file if no checkpoints
//go:generate sh -c "if [ ! -s testnet_checkpoints.dat ]; then echo var testnet_checkpoints = []byte{} >> testnet_checkpoints.go; fi;"

//go:generate sh -c " if [  -s testnet_checkpoints.dat ]; then echo var testnet_checkpoints = []byte{ >> testnet_checkpoints.go; fi"
//go:generate sh -c "if [  -s testnet_checkpoints.dat ]; then xxd -i <  testnet_checkpoints.dat >> testnet_checkpoints.go;fi"
//go:generate sh -c "if [  -s testnet_checkpoints.dat ]; then truncate -s-1 testnet_checkpoints.go; fi"
//go:generate sh -c "if [  -s testnet_checkpoints.dat ]; then echo ,} >> testnet_checkpoints.go;fi "

import "fmt"

import "github.com/romana/rlog"

import "github.com/arnaucode/derosuite/crypto"
import "github.com/arnaucode/derosuite/globals"

// this file handles and maintains checkpoints which are used by blockchain to skip some checks on known parts of the chain
// the skipping of the checks can be disabled by command line arguments

var mainnet_checkpoints_height uint64 = uint64(len(mainnet_checkpoints) / 32) // each checkpoint is 32 bytes in size
var testnet_checkpoints_height uint64 = uint64(len(testnet_checkpoints) / 32) // each checkpoint is 32 bytes in size

func init() {
	rlog.Tracef(1, "Loaded %d checkpoints for mainnet hardcoded", mainnet_checkpoints_height)
	rlog.Tracef(1, "Loaded %d checkpoints for testnet hardcoded", testnet_checkpoints_height)
}

// gives length of currently available checkpoints
func Length() uint64 {
	switch globals.Config.Name {
	case "mainnet":
		return mainnet_checkpoints_height
	case "testnet":
		return testnet_checkpoints_height
	default:
		return 0
	}

	// we can never reach here
	//return 0
}

// tell whether a checkpoint is known in the current selected network
func IsCheckPointKnown(hash crypto.Hash, height uint64) (result bool) {

	var known_hash crypto.Hash

	switch globals.Config.Name {
	case "mainnet":
		if height < mainnet_checkpoints_height {
			copy(known_hash[:], mainnet_checkpoints[32*height:])
			if known_hash == hash {
				result = true
				return
			}
		}

	case "testnet":
		if height < testnet_checkpoints_height {
			copy(known_hash[:], testnet_checkpoints[32*height:])
			if known_hash == hash {
				result = true
				return
			}
		}

	default:
		panic(fmt.Sprintf("Unknown Network \"%s\"", globals.Config.Name))
	}
	return
}
